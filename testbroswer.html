<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Audio/Text Test Client</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        @keyframes recording-blink {
            0% { opacity: 1; } 50% { opacity: 0.2; } 100% { opacity: 1; }
        }
        .recording { animation: recording-blink 1.5s infinite; }
        .token-field { 
            word-break: break-all; 
            max-height: 100px;
            overflow-y: auto;
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 p-4 md:p-8">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-2xl font-bold text-center text-blue-400 mb-6">WebSocket 테스트 클라이언트</h1>

        <!-- 0. 인증 섹션 (동일) -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-6">
            <h2 class="text-xl font-semibold mb-4 text-white">0. 인증 (Authentication)</h2>
            <div class="grid md:grid-cols-2 gap-6">
                <!-- 회원가입 -->
                <div>
                    <h3 class="text-lg font-medium text-gray-300 mb-3">회원가입 (Signup)</h3>
                    <input type="text" id="signupUsername" class="w-full p-3 bg-gray-700 rounded-md border border-gray-600 mb-3" placeholder="Username">
                    <input type="password" id="signupPassword" class="w-full p-3 bg-gray-700 rounded-md border border-gray-600 mb-3" placeholder="Password">
                    <button id="signupBtn" class="w-full bg-blue-800 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Signup</button>
                </div>
                <!-- 로그인 -->
                <div>
                    <h3 class="text-lg font-medium text-gray-300 mb-3">로그인 (Login)</h3>
                    <input type="text" id="loginUsername" class="w-full p-3 bg-gray-700 rounded-md border border-gray-600 mb-3" placeholder="Username">
                    <input type="password" id="loginPassword" class="w-full p-3 bg-gray-700 rounded-md border border-gray-600 mb-3" placeholder="Password">
                    <button id="loginBtn" class="w-full bg-green-700 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">Login & Get Token</button>
                </div>
            </div>
            <div class="mt-4">
                <label class="block text-sm font-medium text-gray-400 mb-2">발급된 JWT 토큰:</label>
                <div id="tokenDisplay" class="w-full p-3 bg-gray-900 rounded-md border border-gray-600 text-green-400 token-field text-xs">
                    (로그인 시 토큰이 여기에 표시됩니다)
                </div>
            </div>
        </div>

        <!-- 1. 연결 설정 (동일) -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-6">
            <h2 class="text-xl font-semibold mb-4 text-white">1. 연결 설정</h2>
            <div class="mb-4">
                <label for="wsUrl" class="block text-sm font-medium text-gray-400 mb-2">WebSocket URL:</label>
                <input type="text" id="wsUrl" class="w-full p-3 bg-gray-700 rounded-md border border-gray-600" value="ws://localhost:8080/ws/simulation?token=[TOKEN]&scenario=loan_scam&mode=voice">
            </div>
            <div class="flex space-x-4">
                <button id="connectBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">연결 (Connect)</button>
                <button id="disconnectBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg" disabled>연결 종료 (Disconnect)</button>
            </div>
            <div id="statusIndicator" class="mt-4 text-center font-semibold text-gray-500">연결되지 않음</div>
        </div>

        <!-- 2. 테스트 영역 (동일) -->
        <div class="grid md:grid-cols-2 gap-6">
            <!-- Text 모드 -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-4 text-white">2a. Text 모드 테스트</h2>
                <div class="flex space-x-4">
                    <input type="text" id="textMessage" class="flex-grow p-3 bg-gray-700 rounded-md border border-gray-600" placeholder="'text' 모드에서 메시지 입력..." disabled>
                    <button id="sendTextBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg" disabled>전송</button>
                </div>
            </div>
            <!-- Voice 모드 -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-4 text-white">2b. Voice 모드 테스트</h2>
                <div class="flex items-center space-x-4">
                    <button id="recordBtn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg" disabled>
                        녹음 시작 (Start)
                    </button>
                    <div id="recordIndicator" class="w-6 h-6 bg-red-500 rounded-full hidden"></div>
                </div>
                <p class="text-xs text-gray-500 mt-2">"녹음 중지"를 누르면 녹음된 전체 파일이 한 번에 전송됩니다.</p>
            </div>
        </div>

        <!-- 3. 로그 (동일) -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg mt-6">
            <h2 class="text-xl font-semibold mb-4 text-white">3. 로그 (서버 메시지)</h2>
            <div id="logOutput" class="h-64 w-full bg-gray-900 border border-gray-700 rounded-md p-4 overflow-y-auto text-sm font-mono whitespace-pre-wrap"></div>
        </div>
    </div>

    <script>
        // DOM 요소 (동일)
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusIndicator = document.getElementById('statusIndicator');
        const wsUrlInput = document.getElementById('wsUrl');
        const sendTextBtn = document.getElementById('sendTextBtn');
        const textMessageInput = document.getElementById('textMessage');
        const recordBtn = document.getElementById('recordBtn');
        const recordIndicator = document.getElementById('recordIndicator');
        const logOutput = document.getElementById('logOutput');
        const signupBtn = document.getElementById('signupBtn');
        const signupUsernameInput = document.getElementById('signupUsername');
        const signupPasswordInput = document.getElementById('signupPassword');
        const loginBtn = document.getElementById('loginBtn');
        const loginUsernameInput = document.getElementById('loginUsername');
        const loginPasswordInput = document.getElementById('loginPassword');
        const tokenDisplay = document.getElementById('tokenDisplay');

        // 변수 (동일)
        let ws = null;
        let mediaRecorder = null;
        let audioChunks = []; // [수정] 청크를 여기에 저장합니다.
        let isRecording = false;
        let jwtToken = null;

        // 로그 유틸리티 함수 (동일)
        function logMessage(message, type = 'info') {
            const time = new Date().toLocaleTimeString();
            const colorClass = {
                info: 'text-gray-400',
                error: 'text-red-400',
                sent: 'text-yellow-400',
                received: 'text-green-400',
                auth: 'text-purple-400'
            }[type];
            logOutput.innerHTML += `<div class="mb-1"><span class="text-gray-600">${time}</span> <span class="${colorClass}">${message}</span></div>`;
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        // UI 상태 업데이트 함수 (동일)
        function updateUIState(isConnected) {
            connectBtn.disabled = isConnected;
            disconnectBtn.disabled = !isConnected;
            wsUrlInput.disabled = isConnected;
            signupBtn.disabled = false;
            loginBtn.disabled = false;
            sendTextBtn.disabled = !isConnected;
            textMessageInput.disabled = !isConnected;
            recordBtn.disabled = !isConnected;
            if (isConnected) {
                statusIndicator.textContent = '연결됨 (Connected)';
                statusIndicator.classList.remove('text-gray-500');
                statusIndicator.classList.add('text-green-500');
            } else {
                statusIndicator.textContent = '연결되지 않음 (Disconnected)';
                statusIndicator.classList.remove('text-green-500');
                statusIndicator.classList.add('text-gray-500');
                stopRecording(false); // 연결 끊길 시 강제 중지
            }
        }

        // 인증 핸들러 (동일)
        signupBtn.onclick = async () => {
            const username = signupUsernameInput.value;
            const password = signupPasswordInput.value;
            if (!username || !password) { logMessage('Signup: Username과 Password를 모두 입력하세요.', 'error'); return; }
            try {
                const response = await fetch('http://localhost:8080/signup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                const data = await response.json();
                if (!response.ok) { throw new Error(data.error || 'Signup failed'); }
                logMessage(`Signup Success: ${data.message}`, 'auth');
            } catch (err) { logMessage(`Signup Error: ${err.message}`, 'error'); }
        };
        loginBtn.onclick = async () => {
            const username = loginUsernameInput.value;
            const password = loginPasswordInput.value;
            if (!username || !password) { logMessage('Login: Username과 Password를 모두 입력하세요.', 'error'); return; }
            try {
                const response = await fetch('http://localhost:8080/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                const data = await response.json();
                if (!response.ok) { throw new Error(data.error || 'Login failed'); }
                jwtToken = data.token;
                logMessage('Login Success: JWT 토큰을 발급받았습니다.', 'auth');
                tokenDisplay.textContent = jwtToken;
                updateWsUrlWithToken();
            } catch (err) { logMessage(`Login Error: ${err.message}`, 'error'); tokenDisplay.textContent = '(로그인 실패)'; }
        };
        function updateWsUrlWithToken() {
            if (jwtToken) {
                const currentUrl = wsUrlInput.value;
                wsUrlInput.value = currentUrl.replace("[TOKEN]", jwtToken);
                logMessage('WebSocket URL이 토큰으로 자동 업데이트되었습니다.', 'info');
            }
        }

        // WebSocket 이벤트 핸들러 (동일)
        connectBtn.onclick = () => {
            const url = wsUrlInput.value;
            if (!url || url.includes("[TOKEN]")) { logMessage('WebSocket URL을 입력하세요 (먼저 로그인하여 토큰을 발급받아야 합니다).', 'error'); return; }
            ws = new WebSocket(url);
            logMessage(`연결 시도 중: ${url}`, 'info');
            ws.onopen = () => { logMessage('WebSocket 연결 성공.', 'info'); updateUIState(true); };
            ws.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    logMessage(`[S->C Text]: ${event.data}`, 'received');
                } else if (event.data instanceof Blob) {
                    logMessage(`[S->C Binary]: 오디오 데이터 수신 (${event.data.size} bytes). 자동 재생 시도.`, 'received');
                    const audioUrl = URL.createObjectURL(event.data);
                    const audio = new Audio(audioUrl);
                    audio.play().catch(e => { logMessage(`오디오 자동 재생 실패 (브라우저 정책): ${e.message}`, 'error'); });
                }
            };
            ws.onerror = (error) => { logMessage(`WebSocket 오류: ${error.message || '연결 실패. URL과 서버 상태를 확인하세요.'}`, 'error'); console.error('WebSocket Error:', error); };
            ws.onclose = (event) => { logMessage(`WebSocket 연결 종료 (Code: ${event.code}, Reason: ${event.reason || 'N/A'})`, 'info'); updateUIState(false); ws = null; };
        };
        disconnectBtn.onclick = () => { if (ws) { ws.close(1000, "Client initiated disconnect"); } };

        // Text 모드 전송 (동일)
        sendTextBtn.onclick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const message = textMessageInput.value;
                if (!message) return;
                ws.send(message);
                logMessage(`[C->S Text]: ${message}`, 'sent');
                textMessageInput.value = '';
            }
        };
        textMessageInput.onkeydown = (e) => { if (e.key === 'Enter') sendTextBtn.click(); };

        // --- Voice 모드 전송 (*** 로직 수정 ***) ---
        recordBtn.onclick = () => {
            if (isRecording) {
                stopRecording(true); // 'true'는 전송을 의미
            } else {
                startRecording();
            }
        };

        async function startRecording() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                logMessage('오디오 녹음이 이 브라우저에서 지원되지 않습니다.', 'error');
                return;
            }
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logMessage('WebSocket이 연결되어 있지 않습니다.', 'error');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm; codecs=opus' });
                
                // [수정] 청크를 전역 배열에 저장
                audioChunks = []; 
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                // [수정] 녹음 중지 시, 모든 청크를 합쳐서 전송
                mediaRecorder.onstop = () => {
                    if (ws && ws.readyState === WebSocket.OPEN && audioChunks.length > 0) {
                        // 모든 청크를 하나의 Blob으로 합침
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm; codecs=opus' });
                        
                        // [핵심] 하나의 Blob을 바이너리로 전송
                        ws.send(audioBlob);
                        logMessage(`[C->S Binary]: ★전체 오디오 전송★ (${audioBlob.size} bytes)`, 'sent');
                        
                        // 서버의 'handleReceiveAudio'가 이 Blob을 받아 하나의 파일로 저장해야 함
                        
                        audioChunks = []; // 버퍼 비우기
                    }
                };

                // [수정] start()에 간격을 주지 않으면, stop() 시점에 ondataavailable이 한 번만 호출됨
                mediaRecorder.start(); 
                isRecording = true;
                
                // (UI 업데이트는 동일)
                recordBtn.textContent = '녹음 중지 (Stop & Send)';
                recordBtn.classList.add('bg-gray-600', 'hover:bg-gray-700', 'recording');
                recordBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                recordIndicator.classList.remove('hidden');
                logMessage('마이크 녹음 시작... "녹음 중지"를 누르면 전송됩니다.', 'info');

            } catch (err) {
                logMessage(`마이크 접근 실패: ${err.message}`, 'error');
                console.error('getUserMedia error:', err);
            }
        }

        // [수정] 'sendOnStop' 플래그 추가
        function stopRecording(sendOnStop = true) {
            if (mediaRecorder && isRecording) {
                isRecording = false; // onstop 이벤트 핸들러가 sendOnStop을 참조할 수 있도록 먼저 false로 설정
                
                // [수정] onstop 핸들러가 전송을 수행하도록 로직 변경
                mediaRecorder.onstop = () => {
                    if (sendOnStop && ws && ws.readyState === WebSocket.OPEN && audioChunks.length > 0) {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm; codecs=opus' });
                        ws.send(audioBlob);
                        logMessage(`[C->S Binary]: ★전체 오디오 전송★ (${audioBlob.size} bytes)`, 'sent');
                    } else if (sendOnStop) {
                        logMessage('전송할 오디오 데이터가 없습니다.', 'info');
                    }
                    audioChunks = []; // 버퍼 비우기
                };

                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                
                // (UI 업데이트는 동일)
                recordBtn.textContent = '녹음 시작 (Start)';
                recordBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                recordBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700', 'recording');
                recordIndicator.classList.add('hidden');
                mediaRecorder = null;
                
                if (sendOnStop) {
                    logMessage('녹음 중지. 전체 오디오를 전송합니다.', 'info');
                } else {
                    logMessage('녹음 중지 (연결 끊김).', 'info');
                }
            }
        }

        // 초기 UI 상태 설정
        updateUIState(false);
    </script>

</body>
</html>

